# This allows a larger number of redirects
map_hash_bucket_size 256;

# This included file contains URL redirects from older versions of the
# site.
include redirects.conf;

# Here we define the upstream servers. Docker knows how to connect to
# them based on their names in the docker-compose.*.yml files. Look
# under the `services` key in `docker-compose.production.yml` to see the
# services called `gatsby` and `express_api`.
upstream gatsby {
    server gatsby:8000;
}

upstream express_api {
    server express_api:5000;
}

# The non-HTTPS server (port 80) redirects to the HTTPS server (port
# 443).
server {
    listen 80;
    server_name codeselfstudy.com www.codeselfstudy.com;
    server_tokens off;

    # location /.well-known/acme-challenge/ {
    #     root /var/www/certbot;
    # }

    # No HTTPS internally for now until we can get the certificate into
    # the container.
    # return 301 https://$host$request_uri;

    if ($redirect_uri) {
        return 301 $redirect_uri;
    }

    location /api {
        rewrite /api/(.*) /$1 break;
        proxy_pass http://express_api;
    }

    location / {
        proxy_pass http://gatsby;
    }
}

# server {
#     listen 443 ssl;
#     server_name codeselfstudy.com www.codeselfstudy.com;
#     server_tokens off;
#
#     ssl_certificate /etc/letsencrypt/live/codeselfstudy.com/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/codeselfstudy.com/privkey.pem;
#     include /etc/letsencrypt/options-ssl-nginx.conf;
#     ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
#
#     if ($redirect_uri) {
#         return 301 $redirect_uri;
#     }
#
#     location /api {
#         rewrite /api/(.*) /$1 break;
#         proxy_pass http://express_api;
#     }
#
#     location / {
#         proxy_pass http://gatsby;
#     }
# }
